# FP1155 Contract (Fighting Points)

## Overview

FP1155 is the core token of the UFC Strike / FightFi ecosystem. It's an **ERC-1155 multi-token** representing seasonal, non-tradable reputation points ("Fighting Points"). Each token ID represents a season. Transfers are restricted via an allowlist and agent role system, making FP a controlled ecosystem token rather than a freely tradable asset.

**Contract:** `src/FP1155.sol`
**Network:** BSC (Testnet & Mainnet)
**Pattern:** UUPS Upgradeable Proxy (ERC1967Proxy)
**Solidity:** ^0.8.20
**Dependencies:** OpenZeppelin Contracts Upgradeable v5

---

## Table of Contents

- [Architecture](#architecture)
- [Roles & Access Control](#roles--access-control)
- [Season System](#season-system)
- [Transfer Rules](#transfer-rules)
  - [Allowlist](#allowlist)
  - [Agent Transfers](#agent-transfers)
  - [Transfer Guard Logic](#transfer-guard-logic)
- [Minting](#minting)
- [Claiming (EIP-712)](#claiming-eip-712)
- [Burning](#burning)
- [Admin Functions](#admin-functions)
- [View Functions](#view-functions)
- [Events](#events)
- [Deployment](#deployment)
- [Upgrading](#upgrading)
- [Backend Integration: Claim Signing](#backend-integration-claim-signing)
- [TypeScript Tools](#typescript-tools)
- [Security Considerations](#security-considerations)
- [Test Coverage](#test-coverage)
- [FAQ](#faq)

---

## Architecture

```
                  ┌─────────────────────┐
                  │    ERC1967Proxy      │  <-- All interactions go through this address
                  └─────────┬───────────┘
                            │ delegatecall
                  ┌─────────▼───────────┐
                  │      FP1155          │
                  │                     │
                  │  ERC1155Upgradeable  │  (multi-token standard)
                  │  ERC1155Pausable     │  (emergency pause)
                  │  ERC1155Burnable     │  (token burning)
                  │  AccessControl       │  (role-based access)
                  │  EIP712             │  (claim signatures)
                  │  ReentrancyGuard    │  (reentrancy protection)
                  │  UUPSUpgradeable     │  (proxy upgrades)
                  └─────────┬───────────┘
                            │
           ┌────────────────┼────────────────┐
           │                │                │
    ┌──────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
    │   Booster   │  │ DailyLottery│  │  Deposit    │
    │ (agent)     │  │  (agent)    │  │  (agent)    │
    └─────────────┘  └─────────────┘  └─────────────┘
```

**Storage gap:** `uint256[50] private __gap` reserved for future upgrades.

---

## Roles & Access Control

| Role | Identifier | Capabilities |
|------|-----------|-------------|
| `DEFAULT_ADMIN_ROLE` | `0x00` (OZ default) | Upgrade contract, set URI, manage allowlist, manage roles |
| `MINTER_ROLE` | `keccak256("MINTER_ROLE")` | Call `mint()` and `mintBatch()` |
| `TRANSFER_AGENT_ROLE` | `keccak256("TRANSFER_AGENT_ROLE")` | Call `agentTransferFrom()` (bypasses approval), transfers allowed without allowlist check |
| `SEASON_ADMIN_ROLE` | `keccak256("SEASON_ADMIN_ROLE")` | Call `setSeasonStatus()` to lock seasons |
| `PAUSER_ROLE` | `keccak256("PAUSER_ROLE")` | Call `pause()` and `unpause()` |
| `CLAIM_SIGNER_ROLE` | `keccak256("CLAIM_SIGNER_ROLE")` | Sign EIP-712 claim authorizations (backend wallet) |

**On initialization:**
- `admin` receives `DEFAULT_ADMIN_ROLE`, `PAUSER_ROLE`, `SEASON_ADMIN_ROLE`
- Other roles (MINTER, TRANSFER_AGENT, CLAIM_SIGNER) must be granted separately after deployment

---

## Season System

**Token ID = Season ID.** Each season is a separate ERC-1155 token. Convention example: season "324" = token ID `324_001`.

### Season Status

```solidity
enum SeasonStatus {
    OPEN,    // 0 - Default. Minting, transferring, and claiming are allowed
    LOCKED   // 1 - Only burns allowed. No new mints or transfers.
}
```

**Key rules:**
- All new seasons default to `OPEN` (mapping default = 0)
- Locking is **irreversible** - once LOCKED, cannot revert to OPEN
- Locked seasons still allow burns (users/contracts can destroy tokens)
- Typically lock a season at end-of-season to finalize balances

```solidity
// Lock a season (irreversible)
fp.setSeasonStatus(324_001, FP1155.SeasonStatus.LOCKED);
```

---

## Transfer Rules

FP1155 is **not freely tradable**. Transfers are gated by a combination of the allowlist, agent role, and season status.

### Allowlist

Addresses on the allowlist can send/receive FP tokens in standard transfers. Managed by `DEFAULT_ADMIN_ROLE`:

```solidity
fp.setTransferAllowlist(userAddress, true);  // add
fp.setTransferAllowlist(userAddress, false); // remove
```

Short-circuits if value already matches (no redundant storage writes or events).

### Agent Transfers

Contracts with `TRANSFER_AGENT_ROLE` can transfer tokens between **any** addresses without requiring prior user approval (`setApprovalForAll`). This is the key integration pattern used by Booster, DailyLottery, and Deposit.

```solidity
// Agent moves tokens from user to contract (no approval needed)
fp.agentTransferFrom(user, contractAddr, seasonId, amount, "");
```

**Agents also bypass the allowlist check** - if either endpoint has `TRANSFER_AGENT_ROLE`, the transfer is allowed regardless of allowlist status.

### Transfer Guard Logic

The `_update()` hook enforces rules per token in every transfer:

| Operation | Season OPEN | Season LOCKED |
|-----------|------------|--------------|
| **Mint** (from = 0) | Allowed | Blocked ("mint: season locked") |
| **Burn** (to = 0) | Allowed | **Allowed** (burns always work) |
| **Transfer** | See rules below | Blocked ("transfer: season locked") |

**Transfer rules (season OPEN):**
1. If **either** `from` or `to` has `TRANSFER_AGENT_ROLE` → **allowed**
2. Otherwise, **both** `from` and `to` must be allowlisted → allowed
3. If neither condition met → reverts with `"transfer: endpoints not allowed"`

```solidity
// Check if a transfer would be allowed
bool allowed = fp.isTransfersAllowed(from, to, seasonId);

// Check if an address can participate in transfers
bool ok = fp.endpointAllowed(account); // allowlisted OR has TRANSFER_AGENT_ROLE
```

---

## Minting

Only `MINTER_ROLE` can mint. Season must be OPEN.

```solidity
// Single mint
fp.mint(to, seasonId, amount, "");

// Batch mint (multiple seasons to same address)
fp.mintBatch(to, [season1, season2], [amount1, amount2], "");
```

**Validations:**
- `to != address(0)`
- `amount > 0` (each amount in batch)
- Season must be OPEN
- Caller must have `MINTER_ROLE`
- `nonReentrant`

---

## Claiming (EIP-712)

Users can claim FP tokens using a server-signed EIP-712 signature. This allows the backend to authorize minting without the user needing a direct `MINTER_ROLE`.

### Claim Function

```solidity
function claim(uint256 seasonId, uint256 amount, uint256 deadline, bytes calldata signature) external
```

### Claim Flow

1. User requests FP from the backend
2. Backend signs an EIP-712 struct with `CLAIM_SIGNER_ROLE` wallet
3. User calls `claim()` on-chain with the signature
4. Contract verifies: deadline not passed, season is OPEN, nonce matches, signer has `CLAIM_SIGNER_ROLE`
5. Nonce increments (prevents replay), tokens minted to user

### EIP-712 Domain & Types

```
Domain:
  name:              "FP1155"
  version:           "1"
  chainId:           (network chain ID)
  verifyingContract: (proxy address)

Type:
  Claim(address account, uint256 seasonId, uint256 amount, uint256 nonce, uint256 deadline)
```

### Replay Protection

- `nonces[user]` is a global, monotonically increasing counter per user
- Each claim signature includes the current nonce
- After successful claim, nonce increments
- Unlike DailyLottery (per-day nonces), FP1155 nonces are global across all seasons

---

## Burning

Burns are **always allowed**, even when a season is LOCKED and even when the contract is paused.

```solidity
// Caller or approved operator burns
fp.burn(account, seasonId, amount);
fp.burnBatch(account, [id1, id2], [amount1, amount2]);
```

Custom events with timestamps are emitted alongside standard ERC-1155 events:

```solidity
event Burn(address indexed account, uint256 indexed seasonId, uint256 amount, uint256 timestamp);
event BurnBatch(address indexed account, uint256[] seasonIds, uint256[] amounts, uint256 timestamp);
```

---

## Admin Functions

| Function | Role | Description |
|----------|------|-------------|
| `setURI(newBaseURI)` | `DEFAULT_ADMIN_ROLE` | Update metadata base URI |
| `pause()` | `PAUSER_ROLE` | Pause mints, claims, agent transfers, standard transfers |
| `unpause()` | `PAUSER_ROLE` | Resume operations |
| `setTransferAllowlist(account, allowed)` | `DEFAULT_ADMIN_ROLE` | Add/remove from allowlist |
| `setSeasonStatus(seasonId, status)` | `SEASON_ADMIN_ROLE` | Lock a season (irreversible) |

**Pause effects:**
- Blocks: `mint`, `mintBatch`, `claim`, `agentTransferFrom`, standard transfers
- Does NOT block: burns (users can always exit)

---

## View Functions

| Function | Returns | Description |
|----------|---------|-------------|
| `seasonStatus(seasonId)` | `SeasonStatus` | OPEN or LOCKED |
| `isOnAllowlist(account)` | `bool` | Is address on the transfer allowlist |
| `endpointAllowed(account)` | `bool` | Allowlisted OR has TRANSFER_AGENT_ROLE |
| `isTransfersAllowed(from, to, seasonId)` | `bool` | Would a transfer between these addresses be allowed |
| `nonces(account)` | `uint256` | Current claim nonce for user |
| `balanceOf(account, seasonId)` | `uint256` | Token balance (inherited ERC-1155) |
| `DOMAIN_SEPARATOR()` | `bytes32` | EIP-712 domain separator for client-side signing |
| `uri(tokenId)` | `string` | Token metadata URI (inherited ERC-1155) |

---

## Events

```solidity
event SeasonStatusUpdated(uint256 indexed seasonId, SeasonStatus status);
event AllowlistUpdated(address indexed account, bool allowed);
event ClaimProcessed(address indexed account, uint256 indexed seasonId, uint256 amount, uint256 nonce);
event Burn(address indexed account, uint256 indexed seasonId, uint256 amount, uint256 timestamp);
event BurnBatch(address indexed account, uint256[] seasonIds, uint256[] amounts, uint256 timestamp);
```

Plus standard ERC-1155 events: `TransferSingle`, `TransferBatch`, `ApprovalForAll`.

---

## Deployment

### Initial Deployment

**Script:** `script/DeployUpgradeable.s.sol:DeployUpgradeable`

**Required env vars:**
```bash
PRIVATE_KEY=0x...    # Deployer (gets DEFAULT_ADMIN_ROLE)
```

**Optional env vars:**
```bash
ADMIN=0x...          # Admin address (defaults to deployer)
BASE_URI=ipfs://...  # Metadata URI (defaults to "ipfs://base/{id}.json")
```

**Command:**
```bash
forge script script/DeployUpgradeable.s.sol:DeployUpgradeable \
  --rpc-url <RPC_URL> \
  --broadcast \
  --verify
```

### Post-Deployment Role Setup

**Script:** `script/GrantRoles.s.sol`

Or manually:
```bash
# Grant minter
ts-node tools/fp/grant-minter-role.ts --network testnet --to 0x...

# Grant claim signer (backend)
ts-node tools/fp/grant-claim-signer-role.ts --network testnet --to 0x...

# Grant transfer agent (Booster, DailyLottery, Deposit contracts)
ts-node tools/fp/grant-transfer-agent-role.ts --network testnet --to 0x...
```

---

## Upgrading

**Script:** `script/UpgradeFP1155.s.sol:UpgradeFP1155`

**Required env vars:**
```bash
PRIVATE_KEY=0x...    # Must have DEFAULT_ADMIN_ROLE
PROXY_ADDRESS=0x...  # Existing proxy address
```

**Command:**
```bash
forge script script/UpgradeFP1155.s.sol:UpgradeFP1155 \
  --rpc-url <RPC_URL> \
  --broadcast
```

---

## Backend Integration: Claim Signing

### TypeScript Example

```typescript
const domain = {
  name: "FP1155",
  version: "1",
  chainId: 97,  // BSC testnet (56 for mainnet)
  verifyingContract: FP1155_PROXY_ADDRESS,
};

const types = {
  Claim: [
    { name: "account", type: "address" },
    { name: "seasonId", type: "uint256" },
    { name: "amount", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
  ],
};

// Get current nonce
const nonce = await fp.nonces(userAddress);
const deadline = Math.floor(Date.now() / 1000) + 86400; // 24h from now

const value = {
  account: userAddress,
  seasonId: 324_001,
  amount: 100,
  nonce: nonce,
  deadline: deadline,
};

const signature = await signerWallet.signTypedData(domain, types, value);
// Return { seasonId, amount, deadline, signature } to user
```

User then submits:
```typescript
await fp.claim(seasonId, amount, deadline, signature);
```

---

## TypeScript Tools

Located in `tools/fp/`:

| Tool | Description | Example |
|------|-------------|---------|
| `mint.ts` | Mint tokens to address | `ts-node tools/fp/mint.ts --network testnet --to 0x... --seasonId 2501 --amount 1000` |
| `claim.ts` | Submit a signed claim | `ts-node tools/fp/claim.ts --season 2501 --amount 100` |
| `transfer.ts` | Transfer tokens | `ts-node tools/fp/transfer.ts --network testnet --to 0x... --seasonId 2501 --amount 50` |
| `balance.ts` | Check balance | `ts-node tools/fp/balance.ts --network testnet --to 0x... --seasonId 2501` |
| `check-roles.ts` | View all roles for address | `ts-node tools/fp/check-roles.ts --network testnet --address 0x...` |
| `set-allowlist.ts` | Manage allowlist | `ts-node tools/fp/set-allowlist.ts --network testnet --address 0x... --allowed true` |
| `set-season-status.ts` | Lock/view season | `ts-node tools/fp/set-season-status.ts --network testnet --seasonId 2501 --status locked` |
| `view-season.ts` | View season info | `ts-node tools/fp/view-season.ts --network testnet --seasonId 2501` |
| `grant-minter-role.ts` | Grant MINTER_ROLE | `ts-node tools/fp/grant-minter-role.ts --network testnet --to 0x...` |
| `grant-claim-signer-role.ts` | Grant CLAIM_SIGNER_ROLE | `ts-node tools/fp/grant-claim-signer-role.ts --network testnet --to 0x...` |
| `grant-transfer-agent-role.ts` | Grant TRANSFER_AGENT_ROLE | `ts-node tools/fp/grant-transfer-agent-role.ts --network testnet --to 0x...` |
| `grant-season-admin.ts` | Grant SEASON_ADMIN_ROLE | `ts-node tools/fp/grant-season-admin.ts --network testnet --to 0x...` |

Also in `tools/`:
| `sign-claim.ts` | Server-side: sign a claim | `ts-node tools/sign-claim.ts --contract 0x... --user 0x... --season 2501 --amount 100 --deadline 1700000000` |

**Network flag:** `--network testnet|mainnet` auto-selects RPC and contract addresses from `.env`.

---

## Security Considerations

| Concern | Mitigation |
|---------|-----------|
| Reentrancy | `nonReentrant` on all state-changing functions |
| Claim replay | Monotonic nonce per user, incremented before mint |
| Unauthorized transfers | Allowlist + agent role gating via `_update` hook |
| Season finality | Irreversible lock prevents accidental re-opening |
| Emergency stop | Pausable (blocks all except burns) |
| Signature expiry | Deadline check in `claim()` |
| Upgrade safety | Only `DEFAULT_ADMIN_ROLE` can upgrade; 50-slot storage gap |
| Redundant writes | Short-circuit pattern in `setTransferAllowlist` and `setSeasonStatus` |

---

## Test Coverage

**Test files:**
- `test/FP1155.t.sol` - Main tests (~65 tests)
- `test/FP1155Agent.t.sol` - Agent transfer tests
- `test/FP1155Upgrade.t.sol` - Upgrade functionality tests

| Category | What's Tested |
|----------|--------------|
| Minting | Basic mint, batch mint, locked season blocks mint, zero amount, role check |
| Transfers | Allowlist enforcement, agent bypass, locked season blocks transfer, batch transfers |
| Claims | Valid signature, wrong signer, expired deadline, replay prevention, locked season, paused state |
| Burning | Always allowed (even locked), timestamp events |
| Season | Irreversible lock, redundant update optimization |
| Allowlist | Redundant update optimization, event emission |
| Pause | Blocks mint/transfer/claim, does not block burn |
| Roles | All role-protected functions tested for unauthorized access |
| Upgrades | State preserved, roles preserved, season status preserved, re-initialization blocked |

```bash
forge test --match-contract FP1155 -vv
```

---

## FAQ

**Q: Can users freely trade FP tokens?**
A: No. Both sender and receiver must be allowlisted, or one of them must have `TRANSFER_AGENT_ROLE`. This keeps FP as a controlled ecosystem token.

**Q: What happens when a season is locked?**
A: No new mints, claims, or transfers for that season. Only burns are allowed. Existing balances are frozen in place (read-only).

**Q: Can I unlock a season after locking it?**
A: No. Locking is irreversible by design.

**Q: What's the difference between `claim` and `mint`?**
A: `mint` requires `MINTER_ROLE` (admin/server). `claim` requires a valid EIP-712 signature from `CLAIM_SIGNER_ROLE` and is called by the user themselves (user pays gas).

**Q: Why does `agentTransferFrom` exist instead of using standard `safeTransferFrom`?**
A: `agentTransferFrom` bypasses the `setApprovalForAll` requirement. Contracts like Booster can move user tokens without the user needing to pre-approve them, as long as the contract has `TRANSFER_AGENT_ROLE`.

**Q: What contracts need `TRANSFER_AGENT_ROLE`?**
A: Booster, DailyLottery, Deposit, and any contract that needs to move FP tokens on behalf of users.

**Q: Does pausing affect burns?**
A: No. Burns always work. This ensures users can always exit/destroy their tokens even during emergencies.
